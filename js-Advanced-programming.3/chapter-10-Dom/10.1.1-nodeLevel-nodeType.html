<!DOCTYPE html><!-- 注释1-->
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>节点层次</title>
	<style>
		.box li:nth-child(odd){
			background: skyblue;
		}
		.asd{
			/* width: 100%; */
			/* height: 40px; */
			background: #eee
		}
	</style>
</head>
<body>
	<div id="app">
		<p style="background: pink;">☺☺☺这是一段文字☺☺☺</p>
		<ul class="box">
		    	<li>1</li><!-- 123 -->		    	
		    	<li>2</li>
		    	<li>3</li>
		    	<li>4</li>
		    	<li>5</li>
		</ul>
	</div>
	<script src="http://pv.sohu.com/cityjson?ie=utf-8">console.log(returnCitySN["cip"]+','+returnCitySN["cname"]);</script> 
	<script>
		(function(){
			// 兼容IE8以下浏览器方法：
			if (!Array.prototype.forEach) {
			    Array.prototype.forEach = function(fun) {
			        for (var i = 0; i < this.length; i++) {
			            if (i in this) {
			                fun.call(arguments[1], this[i], i, this);
			            }
			        }
			    };
			};
			var arrLi = document.querySelector(".box").children;
			Array.prototype.forEach.call(arrLi, function(ele, index) {
			    ele.onclick = function() {
			        alert(index)
			    }
			});
		})();
		
		/*OM（文档对象模型）是针对 HTML 和 XML 文档的一个 API（应用程序编程接口）。 DOM 描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分*/
		{
			/*DOM 可以将任何 HTML 或 XML 文档描绘成一个由多层节点构成的结构。
			*节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。
			*每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。
			*节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构*/
			var html = `<html>					
					<head>
						<title>Sample Page</title>
					</head>
					<body>
						<p>Hello World!</p>
					</body>
				</html>`;
			/*文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。
			*在 HTML 页面中，文档元素始终都是<html>元素。
			*在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素
			*
			* 每一段标记都可以通过树中的一个节点来表示： HTML 元素通过元素节点表示，特性（ attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。
			* 总共有 12 种节点类型，这些类型都继承自一个基类型
			*/
		};

		/*☺☺☺※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※※☺☺☺*/
		{
			/*10.1.1 	Node类型
			*DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。
			*这个 Node 接口在JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。
			*JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享着相同的基本属性和方法
			*
			* 每个节点都有一个 nodeType 属性，用于表明节点的类型。
			* 节点类型由在 Node 类型中定义的下列12 个数值常量来表示，任何节点类型必居其一
			*/
			var a = `Node.ELEMENT_NODE(1)；
				 Node.ATTRIBUTE_NODE(2)；
				 Node.TEXT_NODE(3)；
				 Node.CDATA_SECTION_NODE(4)；
				 Node.ENTITY_REFERENCE_NODE(5)；
				 Node.ENTITY_NODE(6)；
				 Node.PROCESSING_INSTRUCTION_NODE(7)；
				 Node.COMMENT_NODE(8)；
				 Node.DOCUMENT_NODE(9)；
				 Node.DOCUMENT_TYPE_NODE(10)；
				 Node.DOCUMENT_FRAGMENT_NODE(11)；
				 Node.NOTATION_NODE(12)。`;
			//1、元素节点
			//2、属性节点
			//3、文本节点
			//8、注释节点
			//9、document文档节点
			//10、DocumentType节点（<!DOCTYPE html>）
			//11、documentFragment文档碎片
			/*通过比较上面这些常量，可以很容易地确定节点的类型，例如：
				if (someNode.nodeType == Node.ELEMENT_NODE){ //在 IE 中无效
					alert("Node is an element.");
				}
			这个例子比较了 someNode.nodeType 与 Node.ELEMENT_NODE 常量。
			如果二者相等，则意味着someNode 确实是一个元素。然而，由于 IE 没有公开 Node 类型的构造函数，因此上面的代码在 IE 中会导致错误。
			为了确保跨浏览器兼容，最好还是将 nodeType 属性与数字值进行比较，如下所示：
				if (someNode.nodeType == 1){ //适用于所有浏览器
					alert("Node is an element.");
				}
			并不是所有节点类型都受到 Web 浏览器的支持。开发人员最常用的就是元素和文本节点*/
			var ul = document.querySelector('ul');			
			var li = document.querySelector('li');
			if(li.nodeType == 1){
				alert("Node 'li' is an element.");
			};


			/*☺☺☺※※※※※※※※※※※※※※※※※※※※※※※※※※※※※☺☺☺*/
			/*1、nodeName 和nodeValue属性
			*要了解节点的具体信息，可以使用 nodeName 和 nodeValue 这两个属性。这两个属性的值完全取决于节点的类型。
			*在使用这两个值以前，最好是像下面这样先检测一下节点的类型
			*/
			var someNode =document.querySelector('p') ,value;
			if (someNode.nodeType == 1){
				value = someNode.nodeName; //nodeName 的值是元素的标签名
			};

			//对于元素节点， nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null
			

			console.log('☺☺☺※※※※※※※※※※※※※※※※※※※※※※※※※※※※※☺☺☺');
			/*2、节点关系*/
			//每个节点都有一个 childNodes 属性，其中保存着一个 NodeList 对象。 
			//NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。
			//请注意，虽然可以通过方括号语法来访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。 
			//NodeList 对象的独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中
			// var li = document.querySelector('li');
			var secondChild = li.childNodes.item(1);
			var liChild = li.childNodes[0];console.log(liChild.nodeType)
			var conut = li.childNodes.length;		//length 属性表示的是访问 NodeList 的那一刻，其中包含的节点数量
			console.log(li.parentNode.childElementCount,'ul子节点个数')

			//对 arguments 对象使用 Array.prototype.slice()方法可以将其转换为数组。而采用同样的方法，也可以将 NodeList 对象转换为数组
			//在 IE8 及之前版本中无效
			var arrayOfNodes = Array.prototype.slice.call(li.childNodes,0);

			//兼容IE8
			function convertToArray(nodes){
				var array = null;
				try {
					array = Array.prototype.slice.call(nodes, 0); //针对非 IE 浏览器
				} catch (ex) {
					array = new Array();
					for (var i=0, len=nodes.length; i < len; i++){
						array.push(nodes[i]);
					}
				}
				return array;
			};
			

			/*每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。
			*包含在 childNodes 列表中的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。
			*此外，包含在childNodes 列表中的每个节点相互之间都是同胞节点。
			*通过使用列表中每个节点的 previousSibling和 nextSibling 属性，可以访问同一列表中的其他节点。
			*列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null
			*
			* 父节点与其第一个和最后一个子节点之间也存在特殊关系。
			* 父节点的 firstChild 和 lastChild属性分别指向其 childNodes 列表中的第一个和最后一个节点。
			* 其中， someNode.firstChild 的值始 终 等 于 someNode.childNodes[0] ， 而 someNode.lastChild 的 值 始 终 等 于 someNode.childNodes [someNode.childNodes.length-1]。
			* 在只有一个子节点的情况下， firstChild 和lastChild 指向同一个节点。如果没有子节点，那么 firstChild 和 lastChild 的值均为 null
			*
			* hasChildNodes()也是一个非常有用的方法，这个方法在节点包含一或多个子节点的情况下返回 true；应该说，这是比查询 childNodes列表的 length 属性更简单的方法
			*
			* 所有节点都有的最后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。
			* 这种关系表示的是任何节点都属于它所在的文档，任何节点都不能同时存在于两个或更多个文档中。
			* 通过这个属性，我们可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点
			*/
			
			console.log(`li.hasChildNodes() = ${li.hasChildNodes()}`);	//true, 包含文本节点
			li.ownerDocument == document;								//true
			li.childNodes.item(0).ownerDocument == document;			//true

			/*查：
				*☺☺☺☺☺☺ul.children ul.childNodes =>获取子节点
				*☺☺☺☺☺☺.childNodes会包含折行的空白节点,注释节点等
				*☺☺☺☺☺☺.children 只包含元素节点 (.children非标准属性，但各主流浏览器都支持此用法)
				*☺☺☺☺☺ .parentNode =>获取父节点
				* ☺☺☺ previousSibling和 nextSibling 属性会匹配到注释节点和换行的空白节点；替代使用prevElementSibling和nextElementSibling
				* ☺☺☺ 同理 firstChild 和 lastChild 属性 同样建议使用 firstElementChild ,lastElementChild
				* ☺*****☺childElementCount：返回子元素（不包括文本节点和注释）的个数
			*/
		

			console.log('☺☺☺※※※※※※※※※※※※※※※※※※※※※※※※※※※※※☺☺☺');
			{
				/*3、操作关系*/
				//因为关系指针都是只读的，所以 DOM 提供了一些操作节点的方法
				
				//增：
				
					/*document.createElement()
					*创建新节点
					*/
					var li1 = document.createElement('li');
					li1.innerText = '6(new)';


					/*appendChild():向 childNodes 列表的末尾添加一个节点;更新完成后，appendChild()返回新增的节点
					*
					* 如果传入到 appendChild()中的节点已经是文档的一部分了，那结果就是将该节点从原来的位置转移到新位置。
					* 即使可以将 DOM 树看成是由一系列指针连接起来的，但任何 DOM 节点也不能同时出现在文档中的多个位置上。
					* 因此，如果在调用 appendChild()时传入了父节点的第一个子节点，那么该节点就会成为父节点的最后一个子节点
					*/	
					var returnLi1 = ul.appendChild(li1);			//1,2,3,4,5,6new
					console.log(returnLi1 == li1);					//true;

					ul.appendChild(ul.children[0]);				//2,3,4,5,6new,1

					/*insertBefore(arg1,arg2):把节点放在 childNodes 列表中某个特定的位置;
					*两个参数：要插入的节点和作为参照的节点
					*插入节点后，被插入的节点会变成参照节点的前一个同胞节点（ previousSibling），同时被方法返回
					*如果参照节点是null，则 insertBefore()与 appendChild()执行相同的操作
					 */
					var li2 = document.createElement('li');
					li2.innerText = '7(new)';
					// ul.insertBefore(li2,ul.children[5]);
					ul.insertBefore(li2,ul.lastElementChild);		//2,3,4,5,6new,7new,1

					/*
					*cloneNode(Boolean):创建调用这个方法的节点的一个完全相同的副本
					*接受一个布尔值参数，表示是否执行深复制
					*为 true的情况下，执行深复制，也就是复制节点及其整个子节点树
					*为 false 的情况下，执行浅复制，即只复制节点本身
					*复制节点不继承原节点的事件
					 */

					var clUl = ul.cloneNode();
					var clUl2 = ul.cloneNode(true);	
					clUl.className = 'box asd ';
					// clUl2.setAttribute('className',"asd")
					document.querySelector('#app').appendChild(clUl);					 
					document.querySelector('#app').appendChild(clUl2);

				//改
					/*
					*replaceChild(arg1,arg2):替换节点
					*两个参数是：要插入的节点和要替换的节点
					*要替换的节点将由这个方法返回并从文档树中被移除，同时由要插入的节点占据其位置
					*
					* 在使用 replaceChild()插入一个节点时，该节点的所有关系指针都会从被它替换的节点复制过来。
					* 尽管从技术上讲，被替换的节点仍然还在文档中，但它在文档中已经没有了自己的位置
					 */
					
					ul.replaceChild(ul.lastElementChild,ul.children[4]);	//2,3,4,5,1,7new
					
				//删
				
					/*removeChild(arg):
					*一个参数，即要移除的节点
					*被移除的节点将成为方法的返回值
					 */
					
					ul.removeChild(ul.children[1]);				//2,4,5,1,7new


				/*文档碎片
				*DocumentFragments 是DOM节点。它们不是主DOM树的一部分。
				*通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。
				*在DOM树中，文档片段被其所有的子元素所代替。
				*
				*因为文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流(reflow)(对元素位置和几何上的计算)。
				*因此，使用文档片段document fragments 通常会起到优化性能的作用(better performance)。
				*可优化性能
				*/				
					var docfrag = document.createDocumentFragment();
					const browserList = [
				    		"Internet Explorer", 
				    		"Mozilla Firefox", 
				    		"Safari", 
				    		"Chrome", 
				    		"Opera"
					];

					browserList.forEach((e) => {
				    		let li = document.createElement("li");
				   	 	li.textContent = e;
				    		docfrag.appendChild(li);
					});

					clUl.appendChild(docfrag);
			};

			/*
			*normalize()，这个方法唯一的作用就是处理文档树中的文本节点。
			*由于解析器的实现或 DOM 操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。
			*当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。
			*如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点
			 */
		};
	</script>
</body>
</html>